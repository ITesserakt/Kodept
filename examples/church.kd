module Prelude =>
// ∀a, b ⇒ a → b → a
fun const ( x ) => \ y => x
// ∀a, b, c ⇒ (a → b) → (c → a) → c → b
fun compose (f , g ) => \ x => f ( g ( x ) )
// ∀a, b, c ⇒ (a → b → c) → a → b → c
fun curry (f , a , b ) => f (a , b )
// ∀a ⇒ a → a
fun id ( x ) => x
enum struct Bool { True , False }
// ∀a, b ⇒ a → b → a
fun true (x , y ) => x
// ∀a, b ⇒ a → b → b
fun false (x, y) => y

// ∀a, b ⇒ a → b → b
fun zero (f , x ) => x
// ∀a, b, c ⇒ ((a → b) → c → a) → (a → b) → c → b
fun succ (n , f , x) => f ( n (f , x ) )
// ∀a, b, c, d ⇒ (a → b → c) → (a → c → d) → a → b → d
fun plus (m , n , f , x ) => n (f , m (f , x ) )
// ∀a, b, c ⇒ (a → b) → (c → a) → c → b
fun mult (m , n , f) => m ( n ( f ) )
// ∀a, b, c, d, e, f, g ⇒
// (((a → b) → (b → c) → c) → (d → d) → (e → f ) → g) → a → f → g
fun pred (n , f , x ) => n (\ g , h => h ( g ( f ) ) , \ u => x , \ v => v)
