%----------------------------------------------------------
\chapter{Программная реализация}
\label{ch:chap3_soft_architecture}
%----------------------------------------------------------


Прототип компилятора для языка Kodept разрабатывается с использованием языка программирования Rust.
Этот язык предлагает надежный концепт управления памятью, не имея при этом сборщика мусора~\cite{RustMemory}.
Кроме того, он соперничает по скорости с C и C++ и применяется в довольно широком спектре приложений.
Основные преимущества выбора этого языка:
\begin{itemize}
    \item Rust работает быстрее за счёт использования мощных оптимизаторов, а так же применяет более строгие требования к разработке в целом,
    \item он предоставляет больше гарантий разработчику, как посредством его системы типов, так и другими средствами, например, borrow checker~\cite{RustBchk},
    \item система сборки создает нативный файл программы~--- его можно запустить, не имея на машине специальных сред выполнения.
\end{itemize}

\section{Варианты использования прототипа компилятора}
\label{sec:usage}

Были составлены варианты использования прототипа компилятора с точки зрения как пользователя программы, так и разработчика проекта~\figref{fig:usage}.
Разработчик компилятора выделен как отдельное действующее лицо, так как ему необходим доступ к расширенной информации о работе процесса компиляции.
Важно понимать, что компилятор всё ещё находится в разработке, поэтому в будущем будет добавлено больше вариантов использования.
Реализация существующих вариантов выполнена в виде набора команд и флагов для интерфейса командной строки.

\begin{figure}[H]
    \centering
    \input{figures/.generated/usage}
    \caption{UML-диаграмма вариантов использования прототипа компилятора языка Kodept}
    \label{fig:usage}
\end{figure}

Рассмотрим варианты использования подробнее.
Пользователь программы взаимодействует с ней посредством интерфейса командной строки (англ. command line interface, CLI).
При этом на выбор ему доступны две команды, отражающие соответсвующий вариант использования: для обработки файла~--- команда \lstinline{run}, для сохранения структуры AST~--- команда \lstinline{graph}.
Приведём пример использования CLI:
\[
    \underbracket{\text{\lstinline{kodept}}}_{\text{имя исполняемого файла}}~
    \underbracket{\text{\lstinline{graph}}}_{\text{команда}}~
    \underbracket{\text{\lstinline{-d -o output}}}_{\text{опции запуска}}~
    \underbracket{\text{\lstinline{examples/church.kd}}}_{\text{путь до исходного файла}}
\]

В результате работы команды \lstinline{graph} будет получен файл, содержащий представление AST на языке \lstinline{dot}~\cite{Dot}.
Примером отрисовки такого файла является рисунок~\ref{fig:ast_dot}.
В процессе выполнения команды компилятор выполняет первые два шага~--- синтаксический и лексический анализы, а затем строит абстрактное синтаксическое дерево.
Эта команда подразумевается в отладочных целях.

Другая команда~---~\lstinline{run} является более комплексной, по сравнению с предыдущей.
В результате её выполнения будут выведены все собранные \textit{диагностики}.
Во время работы команда выполняет лексический, синтаксический и семантический анализы, в том числе и вывод типов.
В будущем подразумевается, что она будет проводить полный цикл компиляции~\figref{fig:pipeline}.
Кроме команд, используются опции компиляции, полный список которых приведён в таблице~\ref{tab:flags}.

\begin{table}[H]
    \centering
    \caption{Опции командной строки, используемые в компиляторе языка Kodept}
    \label{tab:flags}
    \begin{tabular}{|p{25mm}|p{0.25\textwidth}|p{0.5\textwidth}|}
        \hline
        \textbf{Короткое название} & \textbf{Полное название}       & \textbf{Описание}                                  \\\hline
        \texttt{-d}                & \texttt{--debug}               & Включение отладочной печати                        \\\hline
        \texttt{-v}                & \texttt{--verbose}             & Включение подробной печати                         \\\hline
        \texttt{-s}                & \texttt{--severity}            & Установка уровня логирования по-умолчанию          \\\hline
        \texttt{-o}                & \texttt{--out}                 & Путь для записи выходных данных                    \\\hline
        & \texttt{--style}               & Стиль отображения диагностик                       \\\hline
        & \texttt{--tab-width}           & Добавление отступов                                \\\hline
        \texttt{-c}                & \texttt{--color}               & Использование цветной печати                       \\\hline
        & \texttt{--disable-diagnostics} & Отключить вывод диагностик                         \\\hline
        & \texttt{--stdin}               & Чтение входных данных из потока стандартного ввода \\\hline
        \texttt{-e}                & \texttt{--extension}           & Использовать указанное расширение для файлов       \\\hline
        \texttt{-V}                & \texttt{--version}             & Получить версию программы                          \\\hline
    \end{tabular}
\end{table}

Диагностика (диагностическое сообщение)~---сообщение компилятора, выводимое в стандартный поток ошибок.
Она необходима для указания проблемы, ошибки или другой вспомогательной информации об исходном коде.
Диагностики формируются в нескольких местах при выполнении программы.
Например, после синтаксического анализа, все встреченные ошибки синтаксиса трансформируются в диагностики.
Ниже приведен пример диагностики для некоторой функции \lstinline{test} на языке Kodept.

\begin{verbatim}
    note[TC001]: `test` inferred to: Floating -> Floating
  ┌─ examples/test.kd:5:9
5 │     fun test(m) {
  │         ^^^^
\end{verbatim}

Формат диагностики может меняться в зависимости от опций компиляции, но упрощённо выглядит следующим образом:

\begin{align*}
    &\underbracket{\text{\lstinline{bug}}}_{\mathclap{\text{важность}}}
    \underbracket{\text{\lstinline{[TC002]:}}}_{\text{код}}~
    \underbracket{\text{\lstinline{Unimplemented}}}_{\text{основное описание}}\\
    &\underset{\text{место в исходном файле}}{\text{\lstinline{examples/test.kd:9:10}}}\\
    &\text{\lstinline{// code...}}\\
    &~~~~~~\text{\lstinline{TTTT}}\\
\end{align*}
\begin{eqrem}
    & важность~--- уровень важности диагностики, может быть \texttt{note}, \texttt{info}, \texttt{error} и пр., \\
    & код~--- пятибуквенный номер, идентифицирующий диагностику.
\end{eqrem}


\section{Архитектура компилятора}
\label{sec:arch}

В структуре программы почти любого компилятора можно выделить 3 основные части~\cite{CraftingInterpreters}:
frontend, отвечающий за обработку исходного вода, backend, ответственный за работу с внутренним представлением программы и middle-end, выступающий в роли связующего звена.
Следует отметить, что, хоть названия частей и похожи, они имеют мало общего с одноимёнными названиями из сферы веб-разработки.
На рисунке~\ref{fig:pipeline} также отмечены внутренние элементы каждой из частей, а стрелки показывают данные, передаваемые от стадии к стадии.
Результатом компиляции является объектный модуль (файл), в котором содержатся набор символов, отладочная информация, константные данные и др.
Символы в объектном файле представляют собой именованные объекты, позволяющие идентифицировать функции, переменные, типы данных.

\begin{figure}[H]
    \centering
    \input{figures/.generated/pipeline}
    \caption{Схема состояний работы компилятора}
    \label{fig:pipeline}
\end{figure}

Реализация системы типов, описанной в разделе~\ref{sec:hindley-milner}, в языке Kodept является одной из основных задач этой работы.
Поэтому будет подробно рассмотрен семантический анализатор, включающий механизм вывода типов.
Процесс разработки frontend части компилятора был завершён до этой работы и подробно раскрываться не будет.

На рисунке~\ref{fig:semantic_classes} дано более подробное описание семантического анализатора.
При этом сплошная стрелка отображает ассоциацию между объектами, а штриховая~--- зависимость в направлении от зависимого к главному.
С помощью записи \lstinline{0..*} у объекта указывается, что таких объектов может быть от 0 и больше.

\begin{figure}[h]
    \centering
    \input{figures/.generated/arch}
    \caption{UML-диаграмма классов, связанных с семантическим анализатором}
    \label{fig:semantic_classes}
\end{figure}


\section{Разбиение на модули}
\label{sec:modules}

Работать с большими проектами в разы удобнее и эффективнее при грамотном разбиении на модули.
В экосистеме языка Rust такие модули именуются крейтами (англ. crates).
На рисунке~\ref{fig:modules} представлено разбиение на модули проекта Kodept.
При этом стрелки указывают на зависимость одного модуля от другого.

\begin{figure}[H]
    \centering
    \input{figures/.generated/modules}
    \caption{Диаграмма иерархии модулей в исходном коде компилятора Kodept}
    \label{fig:modules}
\end{figure}

В рамках этой работы внимание будет сконцентрировано вокруг модулей \lstinline{kodept-ast}, \lstinline{kodept-interpret} и \lstinline{kodept-inference}, так как именно с помощью них решаются поставленные задачи.
Однако, дадим краткое описание остальных модулей:
\begin{itemize}
    \item \lstinline{kodept-core} отвечает за определение основных структур данных, необходимых в остальных частях приложения, в частности, в нем определена структура \textit{дерева разбора},
    \item \lstinline{kodept-parse} отвечает за лексический и синтаксический анализ, определяя набор синтаксических анализаторов (парсеров), которые генерируют дерево разбора,
    \item \lstinline{kodept-macros} нужен для работы с AST и создания диагностик,
    \item \lstinline{kodept} является корневым модулем и обеспечивает запуск стадий компилятора для входных файлов,
    \item \lstinline{slotgraph} содержит реализацию графа с использованием \textit{генеративной арены}.
\end{itemize}

Дерево разбора (англ. raw lexem tree, RLT)~---подробное синтаксическое дерево, включающее в себя полную информацию об исходном коде.
Необходимо для восстановления конкретной точки в программе при создании диагностики.
В процессе работы программы трансформируется в AST, где каждый узел RLT соответствует определенному узлу AST.

Генеративная арена~--- специальный вид контейнера для объектов в программировании, в котором для каждого объекта присваивается не только уникальный идентификатор, но и поколение.
Благодаря этому решается проблема утечек памяти: когда удаляется объект из обычной арены, то его место ничем не может быть занято, чтобы не нарушить идентификатор.
В то же время в генеративной арене место из-под удалённого объекта может быть переиспользовано с помощью изменения поколения.

В модуле \lstinline{kodept-ast} определена структура AST и принципы его хранения.
Рассмотрим некоторые технические решения, реализованные при проектировании этого модуля.


\section{Организация хранения абстрактного синтаксического дерева}
\label{sec:ast_structure}

Обычно абстрактное синтаксическое дерево реализовано в программе в виде вложенных друг в друга структур с данными, описывающими тот или иной синтаксис языка.
Например, внутреннее представление функции с набором именованных параметров реализовано композицией структур~\figref{fig:func_AST}.

\begin{figure}[H]
    \centering
    \input{figures/.generated/AST_func}
    \caption{Диаграмма классов, представляющих собой узел функции в AST}
    \label{fig:func_AST}
\end{figure}

Основным процессом при работе семантического анализа является обход абстрактного синтаксического дерева с целью применения различных алгоритмов.
Распространено использование так называемого шаблона посетитель (англ. visitor).
Это специальная структура данных, содержащая алгоритмы для обработки каждой вершины дерева.

У такого подхода есть несколько минусов:
\begin{inparaenum}[1)]
    \item обход совершается в рекурсивном стиле, а это значит, что компилятор не способен обрабатывать большие исходные программы,
    \item сложно поддерживать, так как необходимо изменить или добавить необходимые функции в код каждого посетителя при изменении вида AST,
\end{inparaenum}

В итоге был использован другой подход.
Вместо хранения всех структур <<вложенными>> друг в друга~\figref{fig:func_AST}, было решено применить <<графовый>> метод.
Суть его заключается в создании структуры-контейнера \lstinline{SyntaxTree}.
Все исходные структуры переписываются так, что из них убираются любые вложенные структуры, кроме базовых полей (имя и прочее).
Также добавляется специальное поле \lstinline{id}.
Диаграмма классов после преобразования представлена на рисунке~\ref{fig:func_AST_after}.

Такая композиция позволяет хранить все объекты AST в одном месте, линейно.
Кроме того, реализация обхода дерева перестаёт быть рекурсивной и является реализацией алгоритма обхода в глубину.
Для сохранения взаимосвязи между структурами, вводятся методы доступа.
На рисунке~\ref{fig:func_AST_after} таким методом будет \lstinline{parameters}.

\begin{figure}[H]
    \centering
    \input{figures/.generated/AST_func_after}
    \caption{Диаграмма классов после введённого преобразования}
    \label{fig:func_AST_after}
\end{figure}

Рассмотрим подробнее структуру AST на рисунке~\ref{fig:ast_dot}.
В вершинах дерева расположены имена соответствующих структур данных вместе с идентификатором.
Формат записи следующий: $\underset{\text{имя}}{\text{FileDecl}}~\text{[}\underset{\text{идентификатор}}{1}\text{v}\underset{\text{поколение}}{1}\text{]}$.
У всех вершин поколение равно единице, так дерево не модифицировалось.
На некоторых рёбрах дерева расположились теги~--- маркеры, с помощью которых можно различить одинаковые по имени, но разные по семантике структуры.
Например, обе вершины 11 и 12 являются ссылкой, но 11~--- телом, а 12~--- аргументом.


\section{Реализация алгоритма $\mathcal{W}_c$}
\label{sec:algorithm_W}

Реализация механизма вывода типов расположена в модуле \lstinline{kodept-inference}.
В нём также определены структуры для объектов, рассмотренных в разделе~\ref{sec:hindley-milner}.
Согласно рисунку~\ref{fig:modules}, этот модуль не зависит от остальных.
Достигается это тем, что часть AST конвертируется в эквивалентную структуру \lstinline{Language} из модуля \lstinline{kodept-inference}, представляющей собой терм~\eqref{eq:terms}.
Затем для неё выводится тип, используя методы этого же модуля.

В процессе конвертации используется информация из \textit{дерева областей видимости} (англ. scope tree) для правильного определения всех ссылок.
Под ссылкой будем понимать идентификатор, ссылающийся на другой элемент исходного кода.
Например, в листинге~\ref{lst:kodept}, ссылкой является переменная \lstinline{x} в записи \lstinline{f(g(x))}.

\subsection{Анализ областей видимости}
\label{subsec:scope_analysis}

Задачей этого анализа является разбиение AST на области видимости (англ. scopes), при котором строится так называемое дерево областей видимости.
Вершинами дерева является структура \lstinline{Scope}, представленная на рисунке~\ref{fig:scope_class}.
Принцип формирования дерева прост~--- обходится каждая вершина AST, если она является одной из вершин, которые образуют область видимости, то в дерево добавляется новый объект \lstinline{Scope}, содержащий идентификатор текущей вершины AST и её имя.
По мере обхода заполняются ассоциативные массивы для типов (\lstinline{types}) и переменных (\lstinline{variables}) текущей области видимости.
Благодаря им можно узнать, на что ссылалась та или иная ссылка с помощью методов \lstinline{get_var} и \lstinline{get_type}.

\begin{figure}
    \centering
    \input{figures/.generated/scope}
    \caption{UML-диаграмма класса, представляющего вершину в дереве областей видимости}
    \label{fig:scope_class}
\end{figure}

В список вершин, которые могут образовать область видимости, входят: \lstinline{ModDecl}, \lstinline{StructDecl}, \lstinline{EnumDecl}, \lstinline{AbstFnDecl}, \lstinline{BodyFnDecl}, \lstinline{FileDecl}, \lstinline{Exprs}, \lstinline{Lambda}, \lstinline{IfExpr}.

Рассмотрим образование дерева областей видимости~\figref{fig:scopes} на примере программы с листинга~\ref{lst:kodept}.
Рисунок~\ref{fig:ast_dot} является изображением абстрактного синтаксического дерева для этой программы.
В нём присутствует 7 вершин, образующих область видимости, однако в действительности областей 6, так как вершина с идентификатором 17 не имеет дочерних вершин.

\begin{figure}[H]
    \centering
    \input{figures/.generated/scopes}
    \caption{Дерево областей видимости; в каждом элементе дерева в квадратных скобках указывается идентификатор вершины, после~--- имя области видимости}
    \label{fig:scopes}
\end{figure}

\subsection{Преобразование AST в термы}
\label{subsec:ast_transformation}

Определенный в разделе~\ref{sec:inference_algo}, алгоритм вывода типов $\mathcal{W}_c$ не может работать со структурой абстрактного синтаксического дерева.
Для того чтобы проверить типы в программе, необходимо преобразовать AST в подходящую для алгоритма структуру.
При этом преобразуются не всё дерево, а лишь некоторая его часть.
Преобразование происходит с помощью функции \lstinline{convert(...)} по правилам, которые указаны ниже.
Будем использовать нотацию $\underline{e}$ для результата вызова функции \lstinline{convert(e)}.

Правило преобразования функции с телом \lstinline{BodyFnDecl [name, expr, parameters ]}, где \lstinline{parameters}~--- параметры функции, \lstinline{expr}~--- тело функции:

\begin{equation}
    \label{eq:conv_bfn}
    \begin{cases}
        \underline{expr} \text{ если параметров нет}, \\
        \lambda \underline{p1}. \lambda \underline{p2}. \cdots. \underline{expr},
    \end{cases}
\end{equation}
\begin{eqrem}
    & \texttt{p1, p2} $\in$ \texttt{parameters}.
\end{eqrem}

Правило для преобразования применения \lstinline{Appl [ expr, parameters ]}:

\begin{equation}
    \label{eq:conv_appl}
    \begin{cases}
        \underline{expr} \text{ если параметров нет}, \\
        ((\underline{expr}(\underline{p1}))(\underline{p2}))\ldots,
    \end{cases}
\end{equation}
\begin{eqrem}
    & \texttt{p1, p2} $\in$ \texttt{parameters}.
\end{eqrem}

Правило для преобразования набора выражений \lstinline{Exprs [ items ]}:

\begin{align}
    \label{eq:conv_exprs}
    \begin{cases}
    ()
        &\text{ если список \lstinline{items} пуст},\\
        \text{let } n = \underline{i1} \text{ in } (\underline{i2}) &\text{ если } \underline{i1} \ne \text{ let } x = e_1 \text{ in } e_2,\\
        \text{let } x = e_1 \text{ in } \underline{i2} &\text{иначе},
    \end{cases}
\end{align}
\begin{eqrem}
    & \texttt{i1, i2} $\in$ \texttt{items},                                             \\
    & \texttt{n}~--- имя элемента \texttt{i1} (если есть, иначе~--- идентификатор вершины).
\end{eqrem}

Правило для преобразования объявления инициализированной переменной \lstinline{InitVar [ name, expr ]}:

\begin{equation}
    \label{eq:conv_initvar}
    \text{let } name = \underline{expr} \text{ in } name
\end{equation}

Правило для преобразования условного выражения \lstinline{IfExpr [ condition, body, elifs, else ]}, где \lstinline{elifs}~--- список с элементами вида \lstinline{ElifExpr [ condition, body ]}, \lstinline{else} имеет вид \lstinline{ElseExpr [ body ]}:

\begin{equation}
    \label{eq:conv_if}
    \text{if } \underline{condition} \text{ then } \underline{body} \text{ otherwise } e_1,
\end{equation}
\begin{eqrem}
    & $e_i = \text{ if } \underline{efi.condition} \text{ then } \underline{efi.body} \text{ otherwise } e_{i + 1}$, \\
    & $e_n = \underline{else}$,                                                                                      \\
    & \texttt{efi} $\in$ \texttt{elifs}.
\end{eqrem}

Правило для преобразования числовых литералов тривиально и представляет собой использование терма $\text{:num:}$.
Преобразование кортежа~--- преобразование каждого элемента внутри кортежа.
Правило для ссылки \lstinline{Ref [ name] }: $name$.

Правило для преобразования лямбда-функции \lstinline{Lambda [ binds, expr ]}, где \lstinline{binds}~--- список параметров лямбда-функции:

\begin{equation}
    \label{eq:conv_lambda}
    \begin{cases}
        \underline{expr} \text{ если параметров нет}, \\
        \lambda \underline{b1}. \lambda \underline{b2}. \cdots. \underline{expr},
    \end{cases}
\end{equation}
\begin{eqrem}
    & \texttt{b1, b2} $\in$ \texttt{binds}.
\end{eqrem}

Вывод типов в программе проводится отдельно для каждого определения функции с телом.
При этом к структуре функции применяется функция \lstinline{convert} с последующим получением терма $e$.
Затем производится первый этап алгоритма $\mathcal{W}_c$~--- к терму $e$ применяются правила вывода в форме, определённой в разделе~\ref{subsec:inference_rules}.
Таким образом имеется набор предположений $\mathcal{A}$~\eqref{eq:assumption_set} и набор ограничений $\mathcal{C}$.
Для каждого элемента $x: \tau$ набора предположений рекурсивно запускается отдельный процесс преобразования узла AST, определяющего $x$, а результат процесса записывается в контекст $\Gamma$.
Благодаря этому второй этап алгоритма $\mathcal{W}_c$ имеет полностью определенный набор внешних определений $\Gamma$.

После решения ограничений с помощью алгоритма~\ref{eq:solve_algo}, будет получен тип $\tau$ для выражения $e$.
Этот тип обобщается~\eqref{eq:generalize} и выступает в качестве выведенного для рассматриваемой функции.

Рассмотрим работу функции \lstinline{convert} на примере листинга~\ref{lst:kodept}.
В нём содержится одна функция \lstinline{convert}, представляющая собой одно лямбда-выражение.
Последовательно применяя правила преобразования, можно получить следующий терм для этой функции: $\lambda f. \lambda g. \lambda x. f(g(x))$.

%----------------------------------------------------------
