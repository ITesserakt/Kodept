%----------------------------------------------------------
\chapter{Постановка задачи}
\label{ch:task}
%----------------------------------------------------------

\section{Концептуальная постановка задачи}
\label{sec:abstract_task}

Объект разработки: система типов

Цель: реализовать систему вывода и проверки типов

Задачи:
\begin{enumerate}[1)]
    \item спроектировать представления AST в компиляторе,
    \item реализовать анализатор областей видимости,
    \item написать алгоритм для вывода типов.
\end{enumerate}

%----------------------------------------------------------

\section{Математическая постановка задачи}
\label{sec:math_task}

\subsection{Теория типов}
\label{subsec:type_theory}

В разделе представлена информация о специальном разделе математики - теории типов~\cite{TypeTheoryBook}.
Освящены важные понятия - \textit{терм}, \textit{тип}, \textit{суждение} и \textit{система типов}.

Терм $x$ - чаще всего элемент языка программирования, будь то переменная, константа, вызов функции и др.
Например, в Haskell, термами будут: лямбда-функция \lstinline{\x -> x + 1}, определение переменной \lstinline{let x = "Hello" in ()} и т.д.
Как можно заметить, термы могут включать в себя другие термы.

Типом $A$ обозначается метка, приписываемая объектам, например объекты на натюрмортах принадлежат к типу (классу) <<фрукты>>.
Обычно каждому терму соответствует определенный тип - $x: A$.
Типы позволяют строго говорить о возможных действиях над объектом, а также формализовать взаимоотношения между ними.

Система типов же, определяет правила взаимодействия между типами и термами.
В программировании это понятие равноценно понятию типизация.

С помощью суждений можно создавать логические конструкции и \textit{правила вывода}.
Именно благодаря этому теория типов активно применяется в компиляторах в фазе статического анализа программы, как для вывода, так и для проверки соответствия типов.
Более того, согласно изоморфизму Карри-Ховарда~\cite{TypeTheoryArticle} (таблица \ref{tab:curry-hovard-iso}), программы могут быть использованы для доказательства логических высказываний.
Такие доказательства называют автоматическими, и они широко применяется среди таких языков, как Agda, Coq, Idris.

\begin{table}[h]
    \centering
    \caption{Изоморфизм Карри-Ховарда}
    \label{tab:curry-hovard-iso}
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Логическое высказывание} & \textbf{Язык программирования} \\\hline
        Высказывание, $F$, $Q$           & Тип, $A$, $B$                  \\\hline
        Доказательство высказывания $F$  & $x: A$                         \\\hline
        Высказывание доказуемо           & Тип $A$ обитаем                \\\hline
        $F \implies Q$                   & Функция, $A \to B$             \\\hline
        $F \wedge Q$                     & Тип-произведение, $A \times B$ \\\hline
        $F \vee Q$                       & Тип-сумма, $A + B$             \\\hline
        Истина                           & Единичный тип, $\top$          \\\hline
        Ложь                             & Пустой тип, $\bot$             \\\hline
        $\neg F$                         & $A \to \bot$                   \\\hline
    \end{tabular}
\end{table}

Тип $T$ обитаем (англ. inhabitat), если выполняется следующее: $\exists t: \Gamma \vdash t: T$

Наборы суждений образуют предположения (англ. assumptions), которые образуют контекст $\Gamma$.
Правила вывода записываются следующим образом, например правило подстановки:

\begin{equation}
    \label{eq:judgement_substitution}
    \frac{\Gamma \vdash t: T_1, \Delta \vdash T_1 = T_2}{\Gamma, \Delta \vdash t: T_2}
\end{equation}

Выражение~\ref{eq:judgement_substitution} можно трактовать следующим образом: если в контексте $\Gamma$ терм $t$ имеет тип $T_1$, а в контексте $\Delta$ тип $T_1$ равен типу $T_2$, то можно судить, что при наличии обоих контекстов, терм $t$ имеет тип $T_2$.

\subsection{Система типов Хиндли-Милнера}
\label{subsec:hindley-milner}

В результате работы над научно-исследовательской работой, было принято решение использовать систему типов Хиндли-Милнера.
Среди прочих ее особенностей, важно отметить то, что она способна вывести наиболее общий тип выражения, основываясь на аннотациях типов программиста и окружающем контексте.
Предложено использовать её небольшую модификацию с добавлением типов-объединений и некоторых примитивных типов.

Наиболее классическим алгоритмом в этой области является так называемый алгоритм $W$~\cite{UrbanN2009}.

Для определения системы типов необходимо 3 составляющие: набор термов, набор типов и набор суждений.

Термы:
\begin{flalign*}
    a, b, c &\Coloneqq  \\
    & x && (\text{переменная}) \\
    & \lambda x. a && (\text{лямбда-функция}) \\
    & a(b) && (\text{применение аргумента к функции}) \\
    & let ~ a = b ~ in ~ c && (\text{объявление переменной}) \\
    & 1, 2, 3, \ldots && (\text{целочисленный литерал}) \\
    & 1.1, 1.2, 10.0, \ldots && (\text{вещественный литерал}) \\
    & (a, b) && (\text{объединение})
\end{flalign*}

Типы:
\begin{flalign*}
    \iota &\Coloneqq && (\text{примитивный тип}) \\
    & Integral && (\text{целочистенный}) \\
    & Floating && (\text{вещественный}) \\
    \tau, \sigma &\Coloneqq && (\text{мономорфный тип}) \\
    & \iota \\
    & T && (\text{переменная типа}) \\
    & \tau \to \sigma && (\text{функциональный тип}) \\
    & (\tau, \sigma) && (\text{тип-объединение}) \\
    & \Lambda && (\text{пользовательский тип}) \\
    \alpha &\Coloneqq && (\text{полиморфный тип}) \\
    & \tau \\
    & \forall a. \alpha && (\text{параметрический тип})
\end{flalign*}

Благодаря полиморфным типам имеется возможность определять обобщенные функции.
Самый простой пример - функция $id$.
Она имеет следующий тип: $id: \forall a. a \to a$.
Таким образом ее можно вызвать и с аргументом-числом, и с аргументом-функцией.

Работа алгоритма $W$ строится на основе следующих суждений:

\begin{equation}
    \label{eq:taut}
    \tag{TAUT}
    \frac{}{\Gamma \vdash x: \sigma}
\end{equation}

\begin{equation}
    \label{eq:inst}
    \tag{INST}
    \frac{\Gamma \vdash x: \sigma, \sigma' < \sigma}{\Gamma \vdash x: \sigma'}
\end{equation}

Запись $\sigma' < \sigma$ означает, что тип $\sigma'$ более конкретный, чем $\sigma$.

\begin{equation}
    \label{eq:gen}
    \tag{GEN}
    \frac{\Gamma \vdash x: \sigma, a \notin free(\Gamma)}{\Gamma \vdash x: \forall a. \sigma}
\end{equation}

\begin{equation}
    \label{eq:comb}
    \tag{COMB}
    \frac{\Gamma \vdash f: \tau \to \tau', x: \tau}{\Gamma \vdash f(x): \tau'}
\end{equation}

\begin{equation}
    \label{eq:abs}
    \tag{ABS}
    \frac{\Gamma \cup x: \tau \vdash y: \tau'}{\Gamma \vdash \lambda x. y : \tau \to \tau'}
\end{equation}

\begin{equation}
    \label{eq:let}
    \tag{LET}
    \frac{\Gamma \vdash x: \sigma, \Gamma \cup y: \sigma \vdash z: \tau}{\Gamma \vdash (let ~ y = x ~ in ~ z): \tau}
\end{equation}

\begin{equation}
    \label{eq:tuple}
    \tag{TUPLE}
    \frac{\Gamma \vdash x_1: \tau_1, x_2: \tau_2, x_3: \tau_3, \ldots}{\Gamma \vdash (x_1, x_2, x_3, \ldots): (\tau_1, \tau_2, \tau_3, \ldots)}
\end{equation}

Исходя из этих суждений, алгоритм $W$ составляет так называемое дерево вывода.
Если дерево построить удалось, то написанная программа считается верно типизированной.

%----------------------------------------------------------

