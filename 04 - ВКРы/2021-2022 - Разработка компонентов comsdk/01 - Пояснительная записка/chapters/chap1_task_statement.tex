%----------------------------------------------------------
\chapter{Постановка задачи}\label{chap1_taskStatement}
%----------------------------------------------------------
Поскольку объектом разработки является программный каркас comsdk, а предметом разработки -- программное представление графовых описаний алгоритмов в нём, и поскольку данный программный каркас реализует методологию GBSE, то целесообразно ввести необходимые понятия, связанные с графовыми описаниями.

\begin{definition}
    Множеством элементарных состояний данных сложного вычислительного метода (СВМ) будем называть такое множество \(\mathbb{W}\) пар ``имя параметра -- множество допустимых значений параметра'' таких, что \(\mathbb{W}=Ind(string)\times\bigcup_{i=0}^{N_T}\{Ind(T_i)\}\), где \(Ind(X)\) -- оператор индукции, определяющий множество всех возможных значений типа Х, \(string\) -- тип строк в заданном языке программирования и \(T_i\) -- \(i\)-тый произвольный тип заданного языка программирования, \(N_T\) -- число поддерживаемых типов данных в заданном языке программиирования (при поддержке языком пользовательских типов \(N_T\) бесконечно).
\end{definition}

Элементами множества элементарных состояний СВМ могут служить следующие пары:
$$s_a=(\flqq RealParam \frqq, \mathbb{R}),$$
$$s_b=(\flqq IntegerlParam \frqq, \mathbb{Z}),$$
$$s_c=(\flqq MethodName \frqq, Ind(string)),$$
где \(s_a, s_b, s_c \in \mathbb{W}\).

\begin{definition}
    Пространством состояний СВМ \(\mathbb{S}\) будем называть множество таких подмножеств \(S_i\subset\mathbb{W}\), что элементы каждого такого подмножества имеют уникальные имена в рамках этого подмножества, т.е. \(\forall s_1, s_2 \in S_i: s_1 \neq s_2 \Rightarrow pr_1(s_1) \neq pr_1(s_2)\), где \(pr_1(X)\) -- проекция декартова произведения на первую координату соответствующей пары.
\end{definition}

\begin{definition}
    Состоянием СВМ будем называть элемент \(S\in\mathbb{S}\)
\end{definition}

\begin{definition}
    \label{def:CCMData}
    Пусть \(S\in\mathbb{S}\) -- состояние СВМ. Тогда множество \(D\), такое что \(\forall s \in S \exists d \in D : d = (n,v), n = pr_1(s), v \in pr_2(s)\),
    будем называть \emph{данными сложного вычислительного метода} в состоянии $S$.
\end{definition}

Ниже приведены примеры данных в некоторых состояниях:
\begin{gather*}
    D_1 \multimap S_1 = \{(\flqq RealParam \frqq, 1.0), (\flqq StringParam \frqq, \flqq Hello, world! \frqq)\}, \\
    S_1=\{(\flqq RealParam \frqq, \mathbb{R}),(\flqq StringParam \frqq, Ind(string))\},                         \\
    D_2 \multimap S_2 = \{(\flqq N \frqq, 5), (\flqq M \frqq, 3)\},                                             \\
    S_2 = \{(\flqq N \frqq, \mathbb{Z}), (\flqq M \frqq, \mathbb{Z})\}
\end{gather*}

\begin{definition}
    Пусть даны два состояния -- $S_{in}$ и $S_{out}$. Тогда \emph{функцией-обработчиком} $f$, переводящей данные из $S_{in}$ в $S_{out}$, будем называть отображение вида:
    \begin{align*}
        f: & pr_2(s_1) \times pr_2(s_2) \times \dots \times pr_2(s_n) \rightarrow              \\
           & pr_2(\tilde{s_1}) \times pr_2(\tilde{s_2}) \times \dots \times pr_2(\tilde{s_m}),
    \end{align*}
    где $s_1, s_2, \dots, s_n \in S_{in}$, а $\tilde{s_1}, \tilde{s_2}, \dots, \tilde{s_m} \in S_{out}$, $n = |S_{in}|, m = |S_{out}|$. При этом состояние $S_{in}$ назовём \emph{входным} для функции обработчика, а состояние $S_{out}$ -- \emph{выходным}.
\end{definition}


Для случая, когда на вход функции-обработчику $f$, ожидающей данные $D \multimap S$, подаются именно такие данные, возможно получение непредсказумых и неверных результатов в силу отсутствия обработки не учтённых при реализации обработчика исключительных ситуаций. Таким образом, требуются некоторые объекты, позвоялющие обрабатывать подобные исключительные ситуации.

\begin{definition}
    Пусть $S_{in}$ -- входное состояние для функции-обработчика $f$. Пусть $\mathbb{D}=\{\{D_i\}^n_{i=1}\:D_i \multimap S_{in}\}$ -- семейство всех возможных данных СВМ в состоянии $S_{in}$, и есть такое разбиение $S_i\rightrightarrows \{S_{true},S_{false}\}$. Тогда \emph{функцией-предикатом} с входными состоянием $S_{in}$ будем называть такое отображение $p:\mathbb{D}\to \{0,1\},$ что существуют два подмножества $\mathbb{D}_{true}$ и $\mathbb{D}_{false}$ такие, что $\mathbb{D}_{true} \cup \mathbb{D}_{false} = \mathbb{D}$, и $\forall D_i \in \mathbb{D}_{true} \Rightarrow p^{-1}(1) = D_i$, где $\mathbb{D}_{true} \multimap S_{true}$, и $\forall D_i \in \mathbb{D}_{false} \Rightarrow p^{-1}(0) = D_i$, где $\mathbb{D}_{false} \multimap S_{false}$
\end{definition}

\begin{definition}
    \emph{Функцией перехода} будем называть объединённую функцию $F = <p,f>$ такую, что её значение получается в соответствии с логикой тренарного оператора языка C/C++: $F(D) = p(D) ? f(D): D$.
\end{definition}

Поскольку для реализации большей части алгоритмов требуется проверка условий, то для их описания требуется некоторый объект, отвечающий за условное ветвление. В методологии GBSE за него отвечают функции-селекторы.

\begin{definition}
    Пусть $S$ -- некоторое состояние СВМ. Пусть $\mathbb{D}=\{\{D_i\}^n_{i=1}\:D_i \multimap S\}$ -- семейство всех возможных данных СВМ в состоянии $S$ и разбиение $S \rightrightarrows \{S_j\}^m_{j=1}$. Тогда \emph{функцией-селектором} будем называть такое отображение $h : \mathbb{D} \rightarrow \mathbb{B}^m$, где $\mathbb{B} = \{0, 1\}, \mathbb{B}^m=\times^m_{k=1}\mathbb{B}$, что $\forall D_i \in \mathbb{D} : D_i \multimap S \Rightarrow \exists!\boldmath{b}\in \mathbb{B}^m: h^{-1}(\boldmath{b})=D_j \multimap S_j$
\end{definition}

Пример работы функции-селектора демонстрирует рисунок~\ref{fig:graphSelector}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/example.selector.png}
    \caption{Пример фрагмента графовой модели с функцией-селектором}
    \label{fig:graphSelector}
\end{figure}

На рисунке~\ref{fig:graphSelector} красным обозначено ребро, переход по которому будет совершён после вызова функции-селектора.

На основании приведённых выше определений можно ввести понятие графовой модели сложного вычислительного метода.
\begin{definition}
    \emph{Графовой моделью (ГМ) СВМ} Г будем называть набор объектов Г$=(G, \Sigma, \Phi, H)$, где $G=(N, E)$ -- ориентированный граф с множеством вершин $V$ и множество рёбер $E$, $\Sigma=\left\{S_j\right\}^m_{j=1}$ -- множество состояний данных алгоритма, $\Phi=\left\{F_i=<p_i, f_i>\right\}^n_{i=1}$ -- множество функций перехода и $H$ -- множество функций-селекторов. Каждой вершине ставится в соответствие состояние $S_j\in\Sigma$, в то время, как каждому ребру ставится в соответствие функция перехода $F_i\in\Phi$.
\end{definition}

Таким образом, реализуемые средства должны давать программное представление для:
\begin{itemize}
    \item состояний данных;
    \item функций-обработчиков;
    \item функций-предикатов;
    \item функций перехода;
    \item функций-селекторов;
    \item вершин графовой модели;
    \item рёбер графовой модели;
    \item самих графовых моделей.
\end{itemize}
Данное представление целесообразно реализовать в виде структур данных.

Кроме того, разрабатываемый алгоритм интерпретации и обхода графовой модели должен использовать обозначенные выше структуры данных.
