%----------------------------------------------------------
\chapter{Постановка задачи}
%----------------------------------------------------------
\section{Концептуальная постановка задачи}\label{sec:concept}
\begin{definition}
    \emph{Графовой моделью} вычислительного метода назовём совокупность операций обработки данных, которые включает в себя данный метод, и ориентированный граф, определяющий очерёдность и логику выполнения обозначенных операций.
\end{definition}
\begin{definition}
    \emph{Ветвью} графовой модели назовём подграф, состоящий из последовательно соединённых друг с другом вершин, такой, что из каждой вершины выходит не более одного ребра.
\end{definition}
Пример ветви графа выделен на рисунке~\ref{fig:graphBranch} красным цветом.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{figures/example.branch.png}
    \caption{Пример графа с выделенной ветвью}
    \label{fig:graphBranch}
\end{figure}

Помимо этого целесообразно обозначить некоторые ключевые особенности логики <<графоориентированного подхода>>.
\begin{enumerate}[1)]
    \item Узлам графовой модели ставятся в соответствие т.н. <<состояния данных>> (см. далее).
    \item \emph{Состоянием данных} называется набор поименованных переменных фиксированного типа (скалярного или векторного), характерных для конкретного этапа описываемого метода.
    \item Рёбрам графовой модели ставятся в соответствие т.н. функции перехода, осуществляющие преобразования данных из одного состояния в другое.
    \item Функции перехода имеют два ключевых компонента: функцию-предикат и функцию-обработчик (см. далее).
    \item \emph{Функцией-обработчиком} $f$ называется функция, непосредственно преобразующая данные из одного состояния в другое.
    \item \emph{Функция-предикат} $p$ ставит в соответствие входному набору данных 1 или 0 согласно внутренней логике. Функция-обработчик выполняется только в случае, когда функция-предикат возвращает значение 1. Ситуация, когда функция-предикат возвращает 0 считается исключительной и обрабатывается отдельно.
\end{enumerate}

<<Графоориентированный подход>> подразумевает параллельное независимых ветвей графа. На рисунке \ref{fig:parallelExample} после выполнения рёбер $F_{12}$~и~$F_{13}$ будет получено два независимых состояния данных $S_2$ и $S_3$ соответственно. Далее возникает задача правильным образом перевести данные из этих состояний в общее состояние $S_4$.
\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.4]{figures/example.parallel.png}
    \caption{Пример графовой модели, требующей параллельного исполнения}
    \label{fig:parallelExample}
\end{figure}

Данный подход значительно увеличивает эффективность использования ресурсов вычислительной системы и ускоряет процесс решения, однако добавляет некоторые второстепенные задачи при разработке. Так в примере на рисунке \ref{fig:parallelExample} рёбра $F_{12}$~и~$F_{13}$ выполнялись параллельно, а значит полученные в результате их выполнения данные существуют в самом общем случае в различных адресных пространствах оперативной памяти (возможно даже на двух разных вычислительных машинах). В момент разветвления графа должно происходить корректное предоставление вычислительным ресурсам (потокам, процессам, узлам кластера и т.п.) доступа к обрабатываемым данным. Помимо этого алгоритм обхода графовой модели должен корректно отрабатывать слияние ветвей графа и в частности при необходимости выполнять сбор данных.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.4]{figures/example.parallel_then_linear.png}
    \caption{Пример графовой модели с совмещением ветвей}
    \label{fig:parallelThenLinearExample}
\end{figure}

На рисунке \ref{fig:parallelThenLinearExample} ветви $S_1 \rightarrow S_2 \rightarrow S_4$ и $S_1 \rightarrow S_3 \rightarrow S_4$ выполняются с использованием различных вычислительных ресурсов, но ребро $F_{45}$ выполняется в пределах одной <<общей>> ветви графа $S_4 \rightarrow S_5$, и в момент его выполнения ресуры, выделенные на выполнение двух паралельных ветвей уже не требуются. Таким образом, целесообразно разработать управляющую структуру, которая бы отвечала за выделение и освобождение вычислительных ресурсов во время работы с несколькими параллельными ветвями графа.

Кроме того, разрабатываемая архитектура должна поддерживать несколько вариантов параллельного исполнения. Среди прочих желательна поддержка:
\begin{itemize}
    \item поочерёдного выполнения (в первую очередь для отладки) в одном потоке управления;
    \item выполнения с использованием нескольких процессов операционной системы;
    \item выполнения с использованием нескольких потоков процессора;
    \item выполнения на удалённых узлах (через SSH-соединение).
\end{itemize}

Таким образом целесообразна поддержка единого интерфейса обозначенной управляющей структуры для разных режимов выполнения (последовательный, параллельный, распределённый и пр.).

В случае, когда параллельного выполнения не требуется и предусмотрено условное ветвление, оно должно быть реализовано при помощи специальных функций, привязываемых к узлам графовой модели. В контексте <<графоориентированного подхода>> такие функции называются \emph{селекторами}. Формально функция-селектор $h_i$, привязанная к узлу $v_i$, должна входному набору данных $\bar{D}$ ставить в соответствие множество рёбер $E_i$, выходящих из $v_i$, проход по которым нужно совершить. Пример работы функции-селектора демонстрирует рисунок~\ref{fig:graphSelector}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/example.selector.png}
    \caption{Пример фрагмента графовой модели с функцией-селектором}
    \label{fig:graphSelector}
\end{figure}

На данном рисунке красным обозначено ребро, переход по которому будет совершён после вызова функции-селектора.

Алгоритмы обхода графовых моделей, предусматривающие условное ветвление и параллельное выполнение ветвей представлены в разделе~\ref{chap2_algorithms}.
%----------------------------------------------------------

