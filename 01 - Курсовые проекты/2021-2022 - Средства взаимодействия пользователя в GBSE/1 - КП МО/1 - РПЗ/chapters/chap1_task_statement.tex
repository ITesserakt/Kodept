%----------------------------------------------------------
\chapter{Постановка задачи}
%----------------------------------------------------------
\section{Концептуальная постановка задачи}\label{sec:concept}

Методология GBSE подразумевает параллельное исполнение рёбер графа, выходящих из одной вершины. На рисунке \ref{fig:parallelExample} после выполнения рёбер $F_{12}$~и~$F_{13}$ будет получено два независимых состояния данных $S_2$ и $S_3$ соответственно. Далее возникает задача правильным образом перевести данные из этих состояний в общее состояние $S_4$.
\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.4]{figures/example.parallel.png}
    \caption{Пример графовой модели, требующей параллельного исполнения}
    \label{fig:parallelExample}
\end{figure}

Данный подход значительно увеличивает эффективность использования ресурсов вычислительной системы и ускоряет процесс решения, однако добавляет некоторые второстепенные задачи при разработке. Так в примере на рисунке \ref{fig:parallelExample} рёбра $F_{12}$~и~$F_{13}$ выполнялись параллельно, а значит полученные в результате их выполнения данные существуют в самом общем случае в различных адресных пространствах оперативной памяти (возможно даже на двух разных вычислительных машинах). В момент разветвления графа должно происходить корректное предоставление вычислительным ресурсам (потокам, процессам, узлам кластера и т.п.) доступа к обрабатываемым данным. Помимо этого алгоритм обхода графовой модели должен корректно отрабатывать слияние ветвей графа и в частности при необходимости выполнять сбор данных.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.4]{figures/example.parallel_then_linear.png}
    \caption{Пример графовой модели с совмещением ветвей}
    \label{fig:parallelThenLinearExample}
\end{figure}

На рисунке \ref{fig:parallelThenLinearExample} ветви $S_1 \rightarrow S_2 \rightarrow S_4$ и $S_1 \rightarrow S_3 \rightarrow S_4$ выполняются с использованием различных вычислительных ресурсов, но ребро $F_{45}$ выполняется в пределах одной <<общей>> ветви графа, и в момент его выполнения ресуры, выделенные на выполнение двух паралельных ветвей уже не требуются. Таким образом, целесообразно разработать управляющую структуру, которая бы отвечала за выделение и освобождение вычислительных ресурсов во время работы с несколькими параллельными ветвями графа.

Кроме того, разрабатываемая архитектура должна поддерживать несколько вариантов параллельного исполнения. Среди прочих желательна поддержка:
\begin{itemize}
    \item поочерёдного выполнения (в первую очередь для отладки) в одном потоке управления;
    \item выполнения с использованием нескольких процессов операционной системы;
    \item выполнения с использованием нескольких потоков процессора;
    \item выполнения на удалённых узлах (через SSH-соединение).
\end{itemize}

Таким образом целесообразна поддержка единого интерфейса обозначенной управляющей структуры для разных режимов выполнения (последовательный, параллельный, распределённый и пр.).

В случае, когда параллельного выполнения не требуется, процедура обхода заметно упрощается. Описание её алгоритма для такого случая представлено на рисунке \ref{fig:flowchartNoBranching}.

\begin{figure}[!ht]
    \centering
    \includegraphics[height=0.6\textheight]{figures/flowchart.graphRunning1.png}
    \caption{Блок-схема алгоритма обхода графовой модели, не предполагающей параллельное исполнение}
    \label{fig:flowchartNoBranching}
\end{figure}


%----------------------------------------------------------

