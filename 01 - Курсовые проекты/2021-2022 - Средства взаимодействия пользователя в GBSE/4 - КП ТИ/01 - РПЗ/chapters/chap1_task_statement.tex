%----------------------------------------------------------
\chapter{Постановка задачи}
%----------------------------------------------------------
\section{Концептуальная постановка задачи}

В ходе выполнения работы необходимо было реализовать программные инструменты описания состояний данных согласно их определению, данному в~\cite{SokolovPershin2018}. Должна также быть реализована возможность сохранять описания состояний данных в файлы с использованием некоторого формата.

\begin{definition}
    Множеством элементарных состояний данных сложного вычислительного метода (СВМ) будем называть такое множество \(\mathbb{W}\) пар ``имя параметра -- множество допустимых значений параметра'' таких, что \(\mathbb{W}=Ind(string)\times\bigcup_{i=0}^{N_T}\{Ind(T_i)\}\), где \(Ind(X)\) -- оператор индукции, определяющий множество всех возможных значений типа Х, \(string\) -- тип строк в заданном языке программирования и \(T_i\) -- \(i\)-тый произвольный тип заданного языка программирования, \(N_T\) -- число поддерживаемых типов данных в заданном языке программиирования (при поддержке языком пользовательских типов \(N_T\) бесконечно).
\end{definition}

Элементами множества элементарных состояний СВМ могут служить следующие пары:
$$s_a=(\flqq RealParam \frqq, \mathbb{R}),$$
$$s_b=(\flqq IntegerlParam \frqq, \mathbb{Z}),$$
$$s_c=(\flqq MethodName \frqq, Ind(string)),$$
где \(s_a, s_b, s_c \in \mathbb{W}\).

\begin{definition}
    Пространством состояний СВМ \(\mathbb{S}\) будем называть множество таких подмножеств \(S_i\subset\mathbb{W}\), что элементы каждого такого подмножества имеют уникальные имена в рамках этого подмножества, т.е. \(\forall s_1, s_2 \in S_i: s_1 \neq s_2 \Rightarrow pr_1(s_1) \neq pr_1(s_2)\), где \(pr_1(X)\) -- проекция декартова произведения на первую координату соответствующей пары.
\end{definition}

\begin{definition}
    Состоянием СВМ будем называть элемент \(S\in\mathbb{S}\)
\end{definition}

\begin{definition}
    \label{def:CCMData}
    Пусть \(S\in\mathbb{S}\) -- состояние СВМ. Тогда множество \(D\), такое что \(\forall s \in S \exists d \in D : d = (n,v), n = pr_1(s), v \in pr_2(s)\),
    будем называть данными сложного вычислительного метода в состоянии S.
\end{definition}

Ниже приведены примеры данных в некоторых состояниях:
\begin{gather*}
    D_1 \multimap S_1 = \{(\flqq RealParam \frqq, 1.0), (\flqq StringParam \frqq, \flqq Hello, world! \frqq)\}, \\
    S_1=\{(\flqq RealParam \frqq, \mathbb{R}),(\flqq StringParam \frqq, Ind(string))\},                         \\
    D_2 \multimap S_2 = \{(\flqq N \frqq, 5), (\flqq M \frqq, 3)\},                                             \\
    S_2 = \{(\flqq N \frqq, \mathbb{Z}), (\flqq M \frqq, \mathbb{Z})\}
\end{gather*}

Данные в соответствующем состоянии, как правило, удобно хранить в виде ассоциативного массива. При реализации структуры данных для внутренного представления состояний данных необходимо для каждого элемента состояния хранить его имя и тип. Помимо этого в целях повышения удобства восприятия данных должна быть включена возможность добавить к каждому элементу состояния данных краткое описание для пояснения роли конкретного входного параметра или промежуточной переменной в реализации вычислительного метода.

Тип отдельной переменной может быть как скалярным (целое, логическое, вещественное с плавающей запятой и пр.), так и сложным <<векторным>> (структурой, классом, массивом и пр.). Примером сложного <<векторного>> типа является, в свою очередь, ассоциативный массив со строковыми ключами, при этом конкретная переменная этого типа будет хранить, как правило, адрес этого массива. В общем случае элементы данного массива могут иметь разные типы. В рассматриваемом случае возникает возможность организации хранения состояния данных в виде иерархических структур.

Таким образом, для описания состояний данных требуется формат, который бы поддерживал гетерогенные (т.е. разнотипные) иерархические структуры данных.

%----------------------------------------------------------

