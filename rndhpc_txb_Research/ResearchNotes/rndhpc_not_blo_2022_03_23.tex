%----------------------------------------------------------
\def\notedate{2022.03.23}
\def\currentauthor{Тришин~И.В., Соколов~А.П.}
%----------------------------------------------------------
\notestatement{rndhpcblo}{Требования к возможностям обхода графовых моделей в GBSE}

Графоориентированный подход \gls{gbse} подразумевает параллельное выполнение рёбер графа, выходящих из одной вершины. На рисунке \ref{fig:parallelExample} после выполнения функций перехода $F_{12}$ и~$F_{13}$, связанных с рёбрами, будет осуществлён переход в два независимых состояния данных $S_2$ и $S_3$ соответственно. Далее возникает задача правильным образом преобразовать данные из этих состояний в общее состояние $S_4$.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.3]{ResearchNotes/rndhpc_not_blo_2022_03_23/example.parallel.png}
    \caption{Пример графовой модели, предполагающей параллельное исполнение}
    \label{fig:parallelExample}
\end{figure}

\begin{remark}
Далее, допуская определённую нестрогость, говоря о том, что \uline{функции перехода, связываемые с рёбрами графовых моделей, выполняются в отдельных потоках выполнения}, будем считать, что они выполняются: либо в общем адресном пространстве текущего процесса выполнения, либо в разных процессах на одной или разных вычислительных системах. 

Другими словами, в рамках настоящей заметки не будем предполагать, что данные, формируемые в параллельных ветках графовой модели, размещаются в общей памяти.
\end{remark}

Рассматриваемый подход может способствовать значительному увеличению эффективности использования ресурсов вычислительной системы и, как следствие, ускорению процесса выполнения\footnote{В случае наличия доступных вычислительных ресурсов: нескольких ядер процессора.}, однако, предполагает необходимость реализации дополнительных второстепенных задач. Так для примера на рис.~\ref{fig:parallelExample} функции перехода $F_{12}$ и~$F_{13}$ должны выполняться параллельно (в двух разных потоках выполнения), а значит полученные в результате их выполнения данные, в общем случае\footnote{Речь идёт о самом общем случае, когда выпонение отдельных функций перехода допускается на разных вычислительных машинах или на кластерных системах с распределённой памятью.}, могут быть размещены в разных адресных пространствах разделённой оперативной памяти. Поэтому встаёт задача сбора этих данных в общую оперативную память при переходе в $S_4$. В момент разветвления графа должно (в общем случае) происходить \flqq разделение\frqq обрабатываемых данных, чтобы каждая ветвь работала со своим экземпляром данных. Помимо этого алгоритм обхода графовой модели должен корректно отрабатывать слияние ветвей графа.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.3]{ResearchNotes/rndhpc_not_blo_2022_03_23/example.parallel_then_linear.png}
    \caption{Пример графовой модели с совмещением ветвей}
    \label{fig:parallelThenLinearExample}
\end{figure}

На рисунке \ref{fig:parallelThenLinearExample} ветви $S_1 \rightarrow S_2 \rightarrow S_4$ и $S_1 \rightarrow S_3 \rightarrow S_4$ выполняются в разных потоках выполнения, но ребро $F_{45}$ должно быть выполнено только в одном потоке (если обратного не предполагает функция перехода этого ребра). Таким образом, очевидна необходимость в некоторой управляющей программной структуре, которая бы обеспечивала управление (запуск и завершение) различных потоков выполнения.

Кроме того, указанная управляющая программная структура должна поддерживать несколько вариантов параллельного исполнения. Среди прочих желательна поддержка:
\begin{enumerate}[label=\arabic*)]
    \item поочерёдного выполнения (в первую очередь для отладки);\messnote{Требуется пояснение! Использованы абстрактные обороты, например: поочерёдное выполнение, многопроцессное выполнение?}
    \item многопроцессного выполнения;\messnote{Требуется пояснение!}
    \item многопоточного выполнения;
    \item выполнения на удалённых узлах (через SSH-соединение).\messnote{Требуется пояснение!}
\end{enumerate}

Т.о. целесообразна поддержка единого интерфейса для различных режимов (стратегий) выполнения (параллельный, последовательный, распределённый и пр.) в рамках обозначенной управляющей программной структуры. % , разработчик мог создавать различные реализации этой структуры для каждого отдельного способа. 

%----------------------------------------------------------
% Атрибуты задачи
\noteattributes{}
%----------------------------------------------------------

