%----------------------------------------------------------
\def\notedate{2023.01.23}
\def\currentauthor{Тришин И.В. (РК6-11М)}
%----------------------------------------------------------
\notestatement{rndhpcpar}{Возможные модификации алгоритма обхода}
%----------------------------------------------------------
\subsubsection{Формулировка задачи}
Решение задачи обхода графовой модели и выполнения функций перехода в описанной ориентированным графом последовательности может быть переформулирована, как задача о распределении заданий между несколькими потоками обработки (англ. worker threads) (при параллельном обходе) или определения очерёдности выполнения задач в одном потоке (при последовательном обходе). В данном контексте под потоками обработки подразумеваются любые аппаратные или программные средства выполнения инструкций: потоки процессора, процессы в операционной системе, узлы распределённого вычислительного кластера и~т.п.

\textbf{Дано:}
\begin{enumerate}[label=\arabic*)]
	\item набор функций перехода, которые необходимо выполнить, $T=\{t_i =\ <f_i, p_i>\}_{i=1}^n$, где $f_i$ и $p_i$ -- соответствующие функции-обработчики и функции предикаты;
	\item набор потоков обработки $W=\{w_j\}_{j=1}^m$;
	\item ориентированный граф, показывающий порядок переходов между состояниями данных $S_k$ сложного вычислительного метода $G = <V, E>$;
	\item данные $D$.
\end{enumerate}
При этом
\begin{enumerate}[label=\arabic*)]
	\item узлам из $V$ ставятся в соответствие тройка $<S_k, h_k, G_k>$, где $h_k$ -- ссылка на функцию-селектор, необходимую для проверки условий при достижении данного узла, а $G_k$ -- ссылка на подграф, который требуется обойти, прежде, чем совершать переходы из состояния $S_k$;
	\item рёбрам из $E$ ставятся в соответствие функции перехода из $T$.
\end{enumerate}

\textbf{Требуется:}
\begin{enumerate}[label=\arabic*)]
	\item совершить переход из начального состояния данных в конечное, выполняя функции перехода;
	\item при достижении каждой вершины $v_i$, если в ней определена функция-селектор $h_i \neq \emptyset$, то перед дальнейшими переходами совершать её вызов и определять рёбра, по которым разрешён переход;
	\item если из состояния $S_i$ требуется совершить только один переход, выполнять его в том же потоке обработки, что и функцию перехода, приведшую в $S_i$; \label{elem:req_keepSameThread}
	\item в параллельном режиме если из вершины $v_i$ выходит несколько рёбер графа и после вызова функции-селектора $h_i$ оказывается разрешённым переход по нескольким рёбрам сразу, то выполнять соответствующие им функции перехода в различных потоках обработки; \label{elem:req_DoParallel}
	\item если в вершину $v_i$ входит несколько рёбер графа, совершать переход из неё только после выполнения функций перехода, связанных со всеми входящими рёбрами; \label{elem:req_syncInJoint}
	\item если в вершину $v_i$ входит несколько рёбер графа $e_k$ и потоки обработки, использованные для выполнения функций перехода $t_k$, не используют общую память, агрегировать полученные в результате их выполнения данные перед дальнейшими переходами; \label{elem:req_aggregateInJoint}
	\item учесть возможность наличия в графе $G$ циклов;
\end{enumerate}

\subsubsection{Предложенные решения}
Для определения числа потоков обработки, необходимого для обхода графа $G$ с максимальной степенью распараллеливания предложено использовать поиск в ширину с учётом максимального размера очереди. За основу был взят алгоритм поиска в ширину, описанный в~\cite{Cormen2005}.
\begin{algorithm}[H]
	\caption{Поиск в ширину на ориентированном графе c заданной начальной вершиной}
	\label{lst:bfs}
	\begin{algorithmic}[1]
		\Procedure{BFS}{G}
		\For{\textbf{each} $v_i \in V$}
		\State color[$v_i$] := WHITE
		\EndFor
		\State Пусть $m = 1$ \Comment{Максимальный размер очереди}

		\State color[$v_0$] := GRAY
		\State Пусть $Q := \emptyset$ -- очередь
		\State push($Q$, $v_0$)
		\While{$Q \neq \emptyset$}
		\State $u$ = pop($Q$)
		\For{\textbf{each} $v: \exists edge(u, v)$}
		\If{color[v] = WHITE}
		\State color[$v$] := GRAY
		\State push($Q$, $v$)
		\EndIf
		\EndFor
		\State color[$u$] := BLACK
		\If{size($Q$) > m}
		\State{$m$ := size($Q$)}
		\EndIf
		\EndWhile
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
Данная процедура может быть проведена перед началом обхода, поэтому необходимые вычислительные ресурсы могут быть выделены заранее.

Для выполнения требования~\ref{elem:req_doParallel} предложено ввести для каждого потока обработки $w_i$ очередь функций перехода, которые данный поток должен выполнить $Q_i$. Тогда при необходимости перехода по нескольким рёбрам одновременно предложено помещать соответствующие функции перехода в очереди доступных потоков. Тогда, пока очередь пуста, поток обработки будет ждать поступления функций для выполнения.

Для выполнения требований~\ref{elem:req_syncInJoint} и \ref{elem:req_aggregateInJoint} необходимо находить вершины, в которые входит несколько рёбер. Самый простой способ это сделать -- использовать матрицу смежности графа $G$. Тогда для вершины $v_i$ информацию о количестве входящих рёбер можно получить из $i$-того столбца матрицы смежности. Данная информация может быть получена до начала обхода графовой модели.

Для выполнения требования~\ref{elem:req_syncInJoint} при использовании нескольких потоков обработки необходимо предусмотреть некоторый аналог барьерной синхронизации в вершине, в которую входит несколько ветвей. Благодаря сделанному ранее выводу, можно определить необходимый <<размер>> барьера из матрицы смежности графа $G$. Данные барьеры могут быть подготовлены до начала обхода графовой модели.

Кроме того, пусть в вершину $v$ входят рёбра $v_1, \dots, v_k$, функции перехода которых выполнялись в потоках $w_1, \dots, w_k$, и из вершины $v$ выходит только одно ребро. Тогда для удовлетворения требования~\ref{elem:req_keepSameThread} предложено явно продолжить выполнение в потоке $w_1$.

%----------------------------------------------------------
% Атрибуты задачи
\noteattributes{}
%----------------------------------------------------------