\def\notedate{2023.02.01}
\def\currentauthor{Журавлев Н.В. (РК6-72Б), Соколов А.П.}
\notestatement{rndhpcedt}{Алгоритм обхода орграфа, описывающего графовую модель сложного вычислительного метода}

Далее используется терминология, введённая в работах \cite{SokPersh2019PCS, SokGolub2021GBSEBL}.  

\begin{task}
Дано: ориентированный граф $G$ (орграф), возможно, содержащий циклы, определённый множествами узлов $\{S_i\}_1^m$ и рёбер $\{e_{ij}\colon i\in[1\ldotp\ldotp M], j\in[1\ldotp\ldotp N]\}$, где $M,N$ -- некоторые целые числа.\\
Требуется: разработать алгоритм обхода орграфа $G$, который описывает графовую модель некоторого сложного вычислительного метода (СВМ)~\cite{SokPersh2019PCS}. Алгоритм должен учитывать, что в некоторых узлах могут быть определены условия перехода от узла к узлу с помощью понятия функция-селектор~\cite{SokGolub2021GBSEBL}.
\end{task}

Рассмотрим некоторый узел $S_i$ орграфа $G$, из которого выходит множество рёбер $E_i=\{e_{ij}\}_1^n$, $n>0$. Для построения алгоритма обхода необходимо определить правила перехода от узла $S_{i}$ к другим узлам.
\begin{enumerate}
  \item Если $n=1$, то переход безусловный, т.е. предполагает вызов связанной с $e_{ij}$ функции перехода $F_{ij}$, где $j$ соответствует номеру следующего узла $S_j$.
  \item Если $n>1$, то переход следует осуществлять по всем рёбрам, которые определяются с помощью функции-селектора $h_i$ (организует ветвление, рис.~\ref{rndhpcedt.20230201.1}), сопоставленной с узлом $S_i$, результат выполнения которой определяет подмножество $\hat{E}_i=\{a_{ik}\colon {a_{ik}\in E_i}, {\pr_k(h_i(D_i))=1}, {D_i \filledemptyspoon S_i}\}$, где $S_i$ -- состояние данных \gls{ccm}, сопоставленное с одноимённым узлом $S_{i}$, $D_i$ -- данные в состоянии $S_i$, $\pr_{i}(r)$ -- операция проекции объекта $r$ на $i$-ю координату. Порядок выбора рёбер из $\hat{E}_i$ для осуществления перехода не важен.
\end{enumerate}

\begin{figure}[!ht]
	\centering
	\def\udoffset{10mm}
	\tikzstyle{ar} = [->, >={Stealth[length=8pt]}]
	\tikzstyle{tx} = [midway,sloped,anchor=center, above]
	\begin{tikzpicture}[node distance=2.8cm, scale=1.4]
		\node[state] (S) [xshift=-10mm] {$S_i, h_i$};
		\node[state] (S0) [left of=S] {$\cdots$};
		\node (Sm1) [left of=S0] {$\cdots$};
		\draw [ar] (Sm1) -- (S0);
		\draw [ar] (S0) -- (S);
		\node[state] (S1) [above right of=S, xshift=5mm] {$S_1$};
		\node[state] (S2) [right of=S, xshift=5mm] {$S_2$};
		\node (S11) [right of=S1, xshift=-5mm] {$\cdots$};
		\node (S12) [right of=S2, xshift=-5mm] {$\cdots$};
		\draw [dashed,ar] (S) -- node [tx] {\small $e_{i1}, b_1=1$} (S1);
		\draw [ar] (S1) -- (S11);
		\draw [dashed,ar] (S) -- node [tx] {\small $e_{i2}, b_2=0$} (S2);
		\draw [ar] (S2) -- (S12);
		\draw [dashed,ar] (S) .. controls +(north:1.25*\udoffset) and +(north:1.25*\udoffset) .. node [tx] {\small $e_{i3}, b_3=0$} (S0);
	\end{tikzpicture}
	\caption{Организация ветвления с помощью функции-селектора $h_i$ из состояния $S_i$, где $\forall D_i\filledemptyspoon S_i\rightrightarrows\{S_j\}_{j=1}^{n}$ и $h_i(D_i)=\mbf{b}=(b_1,b_2,b_3,\ldots,b_n)=(1,0,0,\ldots)$. Очевидно, что для представленной иллюстрации $\hat{E}_i=\{e_{i1}\}$ и переход по ветвям, для которых $b_i=0$, запрещён}
	\label{rndhpcedt.20230201.1}
\end{figure}

\begin{remark}
Реализация $\hat{E}_i$ для каждого $i$ возможна путём формирования структуры данных стек. Заполнение соответствующего стека элементами может быть осуществлено в произвольном порядке\footnote{Должны быть выполнены все функции перехода $F_{ij}$, связанные с соответствующими рёбрами, в произвольном порядке (возможно в многопоточном режиме).}.
\end{remark}
  
%Алгоритм предполагает переход к следующей возможной вершине, если она одна, но если их две и более, то выбирает случайную (на данном шаге возможно добавление эвристики), а остальные заносит в специально созданный стек, за исключением случаев, когда селектор разрешает только одно перемещение, затем выполняется переход. Если в вершине, в которую перешли, требуется более одной дуги для продолжения, то алгоритм в данной вершине делает пометку, что одна дуга уже пришла, затем берёт вершину из стека и продолжает обход относительно неё. При возвращении в эту же вершину, если достаточно вершин пришло, то уже проходит через неё. И данный процесс происходит пока не дойдёт до конечной точки графа.

Для реализации требуемого алгоритма необходимо: сделать класс дуги и в класс узла добавить поля, которые определяют необходимое число для перехода через данный узел и количество дуг, которые уже пришли в узел. Класс дуги содержит два поля: начальный узел и конечный узел.

Рассмотрим работу алгоритма на примере орграфа, представленного на рисунке~\ref{fig:graph}. Начальная вершина называется \textsf{Start}, а конечная \textsf{End}. Селекторы в данном примере отсутствуют.%, однако, их добавление не помешает корректной работе алгоритма.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.55\linewidth]{ResearchNotes/rndhpc_alg_edt_2023_02_01/graph.jpg}
    \caption{Пример орграфа без циклов}
    \label{fig:graph}
\end{figure}

Рассмотрим алгоритм перехода из узла \textsf{Start}. Так как из узла \textsf{Start} выходит два ребра, то выбираем случайное из них (например, ребро \textsf{start$\rightarrow$A}), совершаем соответствующий переход\footnote{Выполняем соответствующую функцию перехода при \flqq боевом \frqq режиме обхода.}, тогда как оставшееся ребро \textsf{start$\rightarrow$B} заносится в стек.\messnote{Может быть в любом случае формировать стек?} После перехода в \textsf{A}  Затем из-за того, что всего доступна только 1 вершина, переход идёт в вершину \textsf{C}.

После этого опять происходит ситуация, что из вершины идёт две дуги. Поступаем аналогично и выбираем вершину \textsf{E}, заносим в стек вершину \textsf{F}. Затем по аналогичной ситуации переходим из \textsf{E} в \textsf{D}, а \textsf{G} заносим в стек.

В случае перехода в вершину \textsf{D}, она требует две дуги, поэтому достаём из стека вершину и это вершина \textsf{G}, которая тоже требует две дуги, поэтому снова достаём из стека вершину. Этой вершиной является \textsf{F}, затем переходим в неё, и далее в вершину \textsf{H}, которая требует 2 дуги.

Снова достаём из стека вершину и это вершина \textsf{В} из неё идёт в вершину \textsf{D}, т.к. уже одна дуга уже пришла, то из неё можно перейти в вершину \textsf{G}. Из которой тоже можно перейти по таким же причинам, затем аналогично \textsf{H}, после этого переходим в \textsf{End} и работа алгоритма заканчивается.

\noteattributes{} 