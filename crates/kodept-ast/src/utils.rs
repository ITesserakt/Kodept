#[macro_export]
macro_rules! make_ast_node_adaptor {
    ($name:ident, lifetimes: [$($life:lifetime$(,)*)*], $wrapper:ident, configs: [$($cfg:meta$(,)*)*]) => {
        $(#[$cfg])*
        pub enum $name<$($life, )*> {
            File($wrapper<$($life, )* FileDeclaration>),
            Module($wrapper<$($life, )* ModuleDeclaration>),
            Struct($wrapper<$($life, )* StructDeclaration>),
            Enum($wrapper<$($life, )* EnumDeclaration>),
            Type($wrapper<$($life, )* Type>),
            TypedParameter($wrapper<$($life, )* TypedParameter>),
            UntypedParameter($wrapper<$($life, )* UntypedParameter>),
            TopLevel($wrapper<$($life, )* TopLevel>),
            TypeName($wrapper<$($life, )* TypeName>),
            Variable($wrapper<$($life, )* Variable>),
            InitializedVariable($wrapper<$($life, )* InitializedVariable>),
            BodiedFunction($wrapper<$($life, )* BodiedFunctionDeclaration>),
            Body($wrapper<$($life, )* Body>),
            BlockLevel($wrapper<$($life, )* BlockLevel>),
            ExpressionBlock($wrapper<$($life, )* ExpressionBlock>),
            Operation($wrapper<$($life, )* Operation>),
            Application($wrapper<$($life, )* Application>),
            Lambda($wrapper<$($life, )* Lambda>),
            Expression($wrapper<$($life, )* Expression>),
            Term($wrapper<$($life, )* Term>),
            Reference($wrapper<$($life, )* Reference>),
            Access($wrapper<$($life, )* Access>),
            Number($wrapper<$($life, )* NumberLiteral>),
            Char($wrapper<$($life, )* CharLiteral>),
            String($wrapper<$($life, )* StringLiteral>),
            Tuple($wrapper<$($life, )* TupleLiteral>),
            Literal($wrapper<$($life, )* Literal>),
            CodeFlow($wrapper<$($life, )* CodeFlow>),
            If($wrapper<$($life, )* IfExpression>),
            Elif($wrapper<$($life, )* ElifExpression>),
            Else($wrapper<$($life, )* ElseExpression>),
            Binary($wrapper<$($life, )* Binary>),
            Unary($wrapper<$($life, )* Unary>),
            AbstractFunction($wrapper<$($life, )* AbstractFunctionDeclaration>),
            ResolvedReference($wrapper<$($life, )* ResolvedReference>),
            ResolvedTypeReference($wrapper<$($life, )* ResolvedTypeReference>),
            ProdType($wrapper<$($life, )* ProdType>),
            SumType($wrapper<$($life, )* SumType>),
            Identifier($wrapper<$($life, )* Identifier>),
        }

        impl<$($life, )*> kodept_core::Named for $name<$($life, )*> {
            fn name(&self) -> &'static str {
                match self {
                    $name::File(_) => "File",
                    $name::Module(_) => "Module",
                    $name::Struct(_) => "Struct",
                    $name::Enum(_) => "Enum",
                    $name::Type(_) => "Type",
                    $name::TypedParameter(_) => "TypedParameter",
                    $name::UntypedParameter(_) => "UntypedParameter",
                    $name::TopLevel(_) => "TopLevel",
                    $name::TypeName(_) => "TypeName",
                    $name::Variable(_) => "Variable",
                    $name::InitializedVariable(_) => "InitializedVariable",
                    $name::BodiedFunction(_) => "BodiedFunction",
                    $name::Body(_) => "Body",
                    $name::BlockLevel(_) => "BlockLevel",
                    $name::ExpressionBlock(_) => "ExpressionBlock",
                    $name::Operation(_) => "Operation",
                    $name::Application(_) => "Application",
                    $name::Lambda(_) => "Lambda",
                    $name::Expression(_) => "Expression",
                    $name::Term(_) => "Term",
                    $name::Reference(_) => "Reference",
                    $name::Access(_) => "Access",
                    $name::Number(_) => "Number",
                    $name::Char(_) => "Char",
                    $name::String(_) => "String",
                    $name::Tuple(_) => "Tuple",
                    $name::Literal(_) => "Literal",
                    $name::CodeFlow(_) => "CodeFlow",
                    $name::If(_) => "If",
                    $name::Elif(_) => "Elif",
                    $name::Else(_) => "Else",
                    $name::Binary(_) => "Binary",
                    $name::Unary(_) => "Unary",
                    $name::AbstractFunction(_) => "AbstractFunction",
                    $name::ResolvedReference(_) => "ResolvedReference",
                    $name::ResolvedTypeReference(_) => "ResolvedTypeReference",
                    $name::ProdType(_) => "ProdType",
                    $name::SumType(_) => "SumType",
                    $name::Identifier(_) => "Identifier"
                }
            }
        }
    };
}
